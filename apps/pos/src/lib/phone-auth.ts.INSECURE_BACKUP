// Phone + OTP + PIN Authentication Service
import { supabase } from './supabase';

// mNotify API Configuration (Ghana SMS)
const MNOTIFY_API_KEY = import.meta.env.VITE_MNOTIFY_API_KEY;
const MNOTIFY_SENDER_ID = import.meta.env.VITE_MNOTIFY_SENDER_ID || 'WarehousePS';

// Send SMS via mNotify (Ghana)
async function sendViaMNotify(phone: string, message: string): Promise<boolean> {
  // Remove the + from phone number for mNotify
  const recipient = phone.replace('+', '');
  
  try {
    const response = await fetch('https://apps.mnotify.net/smsapi', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        key: MNOTIFY_API_KEY,
        to: recipient,
        msg: message,
        sender_id: MNOTIFY_SENDER_ID,
      }).toString(),
    });
    
    const result = await response.text();
    console.log('mNotify response:', result);
    
    // mNotify returns "1000" for success
    return result.trim() === '1000' || result.includes('1000');
  } catch (error) {
    console.error('mNotify SMS error:', error);
    return false;
  }
}

// TODO: Add Termii for Nigeria when you have the API key
async function sendViaTermii(phone: string, message: string): Promise<boolean> {
  console.log(`Termii SMS to ${phone}: ${message}`);
  // Termii integration placeholder
  return false;
}

// Simple hash function for PIN (in production, use bcrypt via Edge Function)
async function hashPIN(pin: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(pin + 'warehousepos-salt');
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function verifyPIN(pin: string, hash: string): Promise<boolean> {
  const inputHash = await hashPIN(pin);
  return inputHash === hash;
}

// Generate 6-digit OTP
function generateOTP(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// Validate PIN strength
export function validatePIN(pin: string): { valid: boolean; error?: string } {
  if (!/^\d{6}$/.test(pin)) {
    return { valid: false, error: 'PIN must be exactly 6 digits' };
  }
  
  // Check for sequential
  const sequential = ['123456', '234567', '345678', '456789', '567890', '654321', '543210', '432109', '321098', '210987'];
  if (sequential.includes(pin)) {
    return { valid: false, error: 'PIN cannot be sequential numbers' };
  }
  
  // Check for repeated
  if (/^(\d)\1{5}$/.test(pin)) {
    return { valid: false, error: 'PIN cannot be all the same digit' };
  }
  
  // Check for common PINs
  const common = ['000000', '111111', '123123', '121212', '696969', '112233'];
  if (common.includes(pin)) {
    return { valid: false, error: 'PIN is too common, choose a different one' };
  }
  
  return { valid: true };
}

// Format phone number for storage
export function formatPhone(phone: string, country: 'GH' | 'NG'): string {
  // Remove all non-digits
  const digits = phone.replace(/\D/g, '');
  
  if (country === 'GH') {
    // Ghana: 024XXXXXXX or 233XXXXXXXXX -> +233XXXXXXXXX
    if (digits.startsWith('233')) {
      return '+' + digits;
    }
    if (digits.startsWith('0')) {
      return '+233' + digits.slice(1);
    }
    return '+233' + digits;
  } else {
    // Nigeria: 0801XXXXXXX or 234XXXXXXXXXX -> +234XXXXXXXXXX
    if (digits.startsWith('234')) {
      return '+' + digits;
    }
    if (digits.startsWith('0')) {
      return '+234' + digits.slice(1);
    }
    return '+234' + digits;
  }
}

interface SendOTPResult {
  success: boolean;
  error?: string;
  message?: string;
  devOTP?: string; // For development mode only
}

interface VerifyOTPResult {
  success: boolean;
  error?: string;
}

interface RegisterResult {
  success: boolean;
  error?: string;
  user?: any;
  tenant?: any;
  store?: any;
}

interface LoginResult {
  success: boolean;
  error?: string;
  user?: any;
  tenant?: any;
  store?: any;
}

// Send OTP via SMS (mNotify for Ghana, Termii for Nigeria)
export async function sendOTP(
  phone: string, 
  country: 'GH' | 'NG',
  purpose: 'registration' | 'login' | 'pin_reset' = 'registration'
): Promise<SendOTPResult> {
  const formattedPhone = formatPhone(phone, country);
  const otp = generateOTP();
  const otpHash = await hashPIN(otp); // Reuse hash function
  
  try {
    // Store OTP in database (expires in 10 minutes)
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000).toISOString();
    
    // Delete any existing OTPs for this phone
    await supabase
      .from('phone_otps')
      .delete()
      .eq('phone', formattedPhone);
    
    // Insert new OTP
    const { error: insertError } = await supabase
      .from('phone_otps')
      .insert({
        phone: formattedPhone,
        otp_hash: otpHash,
        purpose,
        expires_at: expiresAt,
        attempts: 0,
      } as never);
    
    if (insertError) {
      console.error('OTP insert error:', insertError);
      return { success: false, error: 'Failed to generate OTP' };
    }
    
    // Send SMS via appropriate provider
    const smsMessage = `Your WarehousePOS verification code is: ${otp}. Valid for 10 minutes.`;
    let smsSent = false;
    
    if (country === 'GH' && MNOTIFY_API_KEY) {
      // Send via mNotify for Ghana
      smsSent = await sendViaMNotify(formattedPhone, smsMessage);
      if (!smsSent) {
        console.warn('mNotify SMS failed, falling back to dev mode');
      }
    } else if (country === 'NG') {
      // Send via Termii for Nigeria (when configured)
      smsSent = await sendViaTermii(formattedPhone, smsMessage);
    }
    
    // Always log in development for debugging
    console.log(`ðŸ“± OTP for ${formattedPhone}: ${otp} (SMS sent: ${smsSent})`);
    
    return { 
      success: true, 
      message: smsSent ? `OTP sent to ${phone}` : `OTP generated for ${phone}`,
      // In dev mode or if SMS fails, show the OTP for testing
      devOTP: (!smsSent || import.meta.env.DEV) ? otp : undefined
    };
  } catch (error: any) {
    console.error('Send OTP error:', error);
    return { success: false, error: error.message || 'Failed to send OTP' };
  }
}

// Verify OTP
export async function verifyOTP(
  phone: string,
  country: 'GH' | 'NG',
  otp: string,
  purpose: 'registration' | 'login' | 'pin_reset' = 'registration'
): Promise<VerifyOTPResult> {
  const formattedPhone = formatPhone(phone, country);
  
  try {
    // Get OTP record
    const { data: otpRecord, error } = await supabase
      .from('phone_otps')
      .select('*')
      .eq('phone', formattedPhone)
      .eq('purpose', purpose)
      .single();
    
    if (error || !otpRecord) {
      return { success: false, error: 'OTP not found. Please request a new one.' };
    }
    
    // Check if expired
    if (new Date((otpRecord as any).expires_at) < new Date()) {
      await supabase.from('phone_otps').delete().eq('phone', formattedPhone);
      return { success: false, error: 'OTP has expired. Please request a new one.' };
    }
    
    // Check attempts
    if ((otpRecord as any).attempts >= 5) {
      await supabase.from('phone_otps').delete().eq('phone', formattedPhone);
      return { success: false, error: 'Too many attempts. Please request a new OTP.' };
    }
    
    // Verify OTP
    const isValid = await verifyPIN(otp, (otpRecord as any).otp_hash);
    
    if (!isValid) {
      // Increment attempts
      await supabase
        .from('phone_otps')
        .update({ attempts: (otpRecord as any).attempts + 1 } as never)
        .eq('phone', formattedPhone);
      
      return { success: false, error: 'Invalid OTP. Please try again.' };
    }
    
    // OTP is valid - delete it
    await supabase.from('phone_otps').delete().eq('phone', formattedPhone);
    
    return { success: true };
  } catch (error: any) {
    console.error('Verify OTP error:', error);
    return { success: false, error: error.message || 'Failed to verify OTP' };
  }
}

// Register new user with Phone + PIN
export async function registerWithPhone(params: {
  phone: string;
  country: 'GH' | 'NG';
  pin: string;
  businessName: string;
  fullName: string;
  email?: string;
}): Promise<RegisterResult> {
  const { phone, country, pin, businessName, fullName, email } = params;
  const formattedPhone = formatPhone(phone, country);
  
  // Validate PIN
  const pinValidation = validatePIN(pin);
  if (!pinValidation.valid) {
    return { success: false, error: pinValidation.error };
  }
  
  try {
    // Check if phone already exists
    const { data: existingUser } = await supabase
      .from('users')
      .select('id')
      .eq('phone', formattedPhone)
      .single();
    
    if (existingUser) {
      return { success: false, error: 'Phone number already registered. Please login instead.' };
    }
    
    // Hash PIN
    const pinHash = await hashPIN(pin);
    
    // Generate unique slug for tenant
    const slug = businessName.toLowerCase().replace(/[^a-z0-9]/g, '') + '-' + Date.now().toString(36);
    
    // Create tenant
    const { data: tenant, error: tenantError } = await supabase
      .from('tenants')
      .insert({
        name: businessName,
        slug,
        country,
        currency: country === 'GH' ? 'GHS' : 'NGN',
        subscription_status: 'trial',
        trial_ends_at: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(), // 14 days trial
      } as never)
      .select()
      .single();
    
    if (tenantError) {
      console.error('Tenant creation error:', tenantError);
      return { success: false, error: 'Failed to create business' };
    }
    
    // Create default store
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .insert({
        tenant_id: (tenant as any).id,
        name: 'Main Store',
        city: country === 'GH' ? 'Accra' : 'Lagos',
        is_active: true,
      } as never)
      .select()
      .single();
    
    if (storeError) {
      console.error('Store creation error:', storeError);
      // Rollback tenant
      await supabase.from('tenants').delete().eq('id', (tenant as any).id);
      return { success: false, error: 'Failed to create store' };
    }
    
    // Create user (without auth.users link for now - we'll use custom auth)
    const userId = crypto.randomUUID();
    const { data: user, error: userError } = await supabase
      .from('users')
      .insert({
        id: userId,
        tenant_id: (tenant as any).id,
        store_id: (store as any).id,
        phone: formattedPhone,
        pin_hash: pinHash,
        full_name: fullName,
        email: email || null,
        role: 'owner',
        is_active: true,
      } as never)
      .select()
      .single();
    
    if (userError) {
      console.error('User creation error:', userError);
      // Rollback
      await supabase.from('stores').delete().eq('id', (store as any).id);
      await supabase.from('tenants').delete().eq('id', (tenant as any).id);
      return { success: false, error: 'Failed to create user account' };
    }
    
    return {
      success: true,
      user,
      tenant,
      store,
    };
  } catch (error: any) {
    console.error('Registration error:', error);
    return { success: false, error: error.message || 'Registration failed' };
  }
}

// Login with Phone + PIN
export async function loginWithPhone(
  phone: string,
  country: 'GH' | 'NG',
  pin: string
): Promise<LoginResult> {
  const formattedPhone = formatPhone(phone, country);
  
  // Validate PIN format
  if (!/^\d{6}$/.test(pin)) {
    return { success: false, error: 'PIN must be exactly 6 digits' };
  }
  
  try {
    // Find user by phone
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('*, tenant:tenants(*), store:stores(*)')
      .eq('phone', formattedPhone)
      .single();
    
    if (userError || !user) {
      return { success: false, error: 'Invalid phone number or PIN' };
    }
    
    // Check if active
    if (!(user as any).is_active) {
      return { success: false, error: 'Account is deactivated. Please contact support.' };
    }
    
    // Verify PIN
    const isValidPIN = await verifyPIN(pin, (user as any).pin_hash);
    if (!isValidPIN) {
      return { success: false, error: 'Invalid phone number or PIN' };
    }
    
    // Update last login
    await supabase
      .from('users')
      .update({ last_login_at: new Date().toISOString() } as never)
      .eq('id', (user as any).id);
    
    return {
      success: true,
      user: user as any,
      tenant: (user as any).tenant,
      store: (user as any).store,
    };
  } catch (error: any) {
    console.error('Login error:', error);
    return { success: false, error: error.message || 'Login failed' };
  }
}

// Reset PIN
export async function resetPIN(
  phone: string,
  country: 'GH' | 'NG',
  newPIN: string
): Promise<{ success: boolean; error?: string }> {
  const formattedPhone = formatPhone(phone, country);
  
  // Validate new PIN
  const pinValidation = validatePIN(newPIN);
  if (!pinValidation.valid) {
    return { success: false, error: pinValidation.error };
  }
  
  try {
    const pinHash = await hashPIN(newPIN);
    
    const { error } = await supabase
      .from('users')
      .update({ pin_hash: pinHash } as never)
      .eq('phone', formattedPhone);
    
    if (error) {
      return { success: false, error: 'Failed to reset PIN' };
    }
    
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message || 'Failed to reset PIN' };
  }
}
